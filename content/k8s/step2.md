---
title: "쿠버네티스 도입"
date: 2020-01-08T22:50:04+09:00
categories: ["cloud-native"]
tags: ["k8s"]
---
## 1. 컨테이너 오케스트레이션

**오케스트레이션**이란 서비스의 공동 목표를 위해서 서로 다른 역할을 하는 프로세스들을 조정하는 것이다. 여기서 비교될 수 있는 스케줄링 개념은 사용가능한 리소스를 관리하고 가장 효율적으로 실행할 수 있는 워크로드를 할당하는 것이다.


## 2. 도움되는 k8s 툴 및 조언(기록용)

쿠버네티스를 자체 구축시 도움되는 툴
* Redis
* Postgre SQL
* Nginx
* 자동 복구 테스트 도구: Chaos Monkey

쿠버네티스를 이용하는 것은 쉽지않다. 쿠버네티스의 이점을 얻어올 수 있는 상황일 때만 사용하는 것이 좋다. 그리고 자체 쿠버네티스 이용은 **꽤 많은 오버헤드**가 든다. 그렇기에 구글이나 아마존에서 제공하는 **관리형 쿠버네티스나 턴키형 쿠버네티스 솔루션을 사용하는 것을 권장**한다.

## 3.1 쿠버네티스 기본 아키텍처

쿠버네티스(K8S: k-s 사이에 알파벳 숫자가 8개)는 여러 대의 서버가 **하나의 클러스터**로 연결되어 있다.

### 3.1.1 컨트롤 플레인
쿠버네티스를 이루는 클러스터의 *두뇌 역할*을 하는 부분이다. 주로 컨테이너 스케줄링, 서비스관리, API 요청 처리 등의 작업을 수행한다.

컨트롤 플레인의 컴포넌트

    kube-apiserver: 컨트롤 플레인의 프런트엔드 서버의 API 요청을 처리한다.

    etcd: 어떤 노드가 존재하고 클러스터에 어떤 리소스가 존재하는지와 같은 쿠버네티스와 관련된 모든 정보를 저장하는 데이터베이스이다.

    kube-scheduler: 새로 생성된 파드를 실행할 노드를 결정한다.

    kube-controller-manager: 디폴로이먼트와 같은 리소스 컨트롤러를 관리한다.

    cloud-controller-manager: 클라우드 기반 클러스터는 클라우드 업체와 연동하여 로드 밸런서나 디스크 볼륨과 같은 자원을 관리한다.

기본적으로 **컨트롤 플레인** 역할을 하는 마스터 노드는 사용자 워크로드를 실행하지 않는다.


*워크로드*: The amount of work or of working time expected or assigned


### 3.1.2 노드 컴포넌트

    kubelet: 노드에 예약된 워크로드를 실행하기 위해 컨터이너 런타임을 관리하고 상태를 모니터링한다.

    kube-proxy: 서로 다른 노드에 있는 파드 간 통신이나 파드와 인터넷 사이의 네트워크 트래픽을 라우팅한다.

    컨테이너 런타임: 컨터이너를 싲가하고 중지하며 컨테이너 간 통신이나 파드와 인터넷 사이의 네트워크 트래픽을 라우팅한다.


### 3.1.3 장애

컨트롤 플레인 장애: 사용자의 애플리케이션을 다운 시키지는 않는다. 그러나 클러스터에 치명적이다. **쿠버네티스 리소스를 변경하지 못하고 디폴로이먼트와 같은 컨트롤러는 중지된다. 즉 쿠버네티스의 커다란 이점이 사라진다.**  하나의 노드가 장애가 나더라도 클러스터가 쿼럼를 유지할 수 있도록 충분한 수의 마스터 노드가 필요하다.


## 4. ETC..

* 타당한 이유가 없다면 자체 쿠버네티스 운영을 하지 말자. 시간, 노력, 전문 지식에 대한 상당한 투자가 필요할 뿐만 아니라 이렇게 해도 상당히 틀릴 수 있다. 
* 자체 클러스터를 이용해야 한다면 **kops**를 이용하자!. 널리 사용되는 성숙한 도구이며 상용급 클러스터의 관리 및 프로비저닝을 제공한다.
* 구글, 아마존에서 제공하는 관리형 쿠버네티스 서비스를 이용하지 못한다면 턴키형 서비스 사용을 절충안으로 고려해보자.
